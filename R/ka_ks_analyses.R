

#' Find optimal number of peaks in Ks distribution
#' 
#' @param ks A numeric vector of Ks values.
#' @param bootstraps Numeric scalar with the number of bootstrap realizations 
#' of the likelihood ratio statistic. We recommend using a minimum of 1000 
#' bootstraps. Default: 1000.
#' @param max_components Numeric scalar with the maximum number of components 
#' to test. Default: 2. 
#' @param signif Numeric scalar with the significance level for the 
#' likelihood ratio test. Default: 0.05.
#' @param epsilon Numeric scalar with the convergence criterion for the
#' expectation-maximization algorithm.
#'
#' @importFrom mixtools boot.comp
#' @export
#' @rdname find_peak_number
#' @return A numeric scalar with the optimal number of peaks.
#' @examples 
#' data(gma_dups_kaks)
#' ks <- gma_dups_kaks$Ks
#' ks <- ks[!is.na(ks)]
#' 
#' # Remove Ks values > 1 for testing purposes
#' ks <- ks[ks <= 1]
#'
#' # Using only 5 bootstraps for testing purposes
#' bootstraps <- 5
#' npeaks <- find_peak_number(ks, bootstraps, max_components = 2)
#'
find_peak_number <- function(ks, bootstraps = 1000, max_components = 2,
                             signif = 0.05, epsilon = 1e-3) {
    
    # Find the optimal number of peaks
    npeaks <- mixtools::boot.comp(
        ks, max.comp = max_components, B = bootstraps, 
        mix.type = "normalmix", sig = signif, epsilon = epsilon,
        verb = FALSE, hist = FALSE
    )
    
    pvals <- npeaks$p.values
    n_pvals <- length(pvals)
    
    number <- n_pvals
    if(pvals[n_pvals] < signif) {
        number <- n_pvals + 1
    } 
    return(number)
}



#' Find peaks in a Ks distribution by fitting Gaussian Mixture Models (GMMs)
#'
#' @param ks A numeric vector of Ks values.
#' @param npeaks Numeric scalar indicating the number of peaks in 
#' the distribution. If you don't know how many peaks there are, 
#' the optimal number of peaks can be estimated with \code{find_peak_number}. 
#' Default: 2.
#' @param epsilon Numeric scalar with the convergence criterion for the
#' expectation-maximization algorithm.
#'
#' 
#' @return A list with the following elements:
#' \describe{
#'   \item{mean}{Numeric with the estimated means.}
#'   \item{sd}{Numeric with the estimated standard deviations.}
#'   \item{lambda}{Numeric with the estimated mixture weights.}
# }
#' @importFrom mixtools normalmixEM
#' @export
#' @rdname find_ks_peaks
#' @examples 
#' data(gma_dups_kaks)
#' ks <- gma_dups_kaks$Ks
#' ks <- ks[!is.na(ks)]
#' 
#' # Remove Ks values >1 for testing purposes
#' ks <- ks[ks <= 1]
#' 
#' # Find 2 peaks in Ks distribution
#' peaks <- find_ks_peaks(ks, npeaks = 2)
find_ks_peaks <- function(ks, npeaks = 2, epsilon = 1e-3) {
    
    # Find peaks
    peaks <- mixtools::normalmixEM(
        ks, 
        k = npeaks, 
        epsilon = epsilon
    )
    
    # Create result list
    peak_list <- list(
        mean = peaks$mu, 
        sd = peaks$sigma, 
        lambda = peaks$lambda
    )
    return(peak_list)
}


#' Plot histogram of Ks distribution with peaks
#'
#' @param ks A numeric vector of Ks values.
#' @param peaks A list with mean, standard deviation, and amplitude of Ks
#' peaks as generated by \code{find_ks_peaks}.
#' @param binwidth Numeric scalar with binwidth for the histogram.
#' Default: 0.05.
#'
#' @return A ggplot object with a histogram and lines for each Ks peak.
#'
#' @importFrom ggplot2 ggplot aes_ geom_histogram ggplot stat_function
#' labs theme_bw
#' @importFrom stats dnorm
#' @rdname plot_ks_peaks
#' @export
#' @examples 
#' data(gma_dups_kaks)
#' ks <- gma_dups_kaks$Ks
#' ks <- ks[!is.na(ks)]
#' 
#' # Remove Ks values >1 for testing purposes
#' ks <- ks[ks <= 1]
#'
#' # Create list of peaks
#' peaks <- find_ks_peaks(ks, npeaks = 2)
#'
#' # Plot
#' plot_ks_peaks(ks, peaks, binwidth = 0.05)
plot_ks_peaks <- function(ks, peaks = NULL, binwidth = 0.05) {
    
    ks_df <- data.frame(ks = ks)
    
    # Define color palette
    pal <- c("#6A6599FF", "#79AF97FF", "#B24745FF", "#00A1D5FF", 
             "#DF8F44FF", "#374E55FF", "#F39B7FFF", "#3C5488FF")
    
    pal <- as.list(rev(pal[seq_along(peaks$mean)]))

    # Plot 
    p <- ggplot(ks_df, aes_(x = ~ks)) +
        geom_histogram(binwidth = binwidth, color = "black", fill = "grey80") +
        mapply(function(mean, sd, lambda, n, binwidth, color) {
            stat_function(geom = "line", fun = function(x) {
                (dnorm(x, mean = mean, sd = sd)) * n * binwidth * lambda
            }, 
            color = color, size = 1.5)
        }, mean = peaks$mean, sd = peaks$sd, lambda = peaks$lambda,
        n = length(ks_df$ks), binwidth = binwidth,
        color = pal) +
        theme_bw() +
        labs(title = "Ks distribution with peaks", y = "Frequency",
             x = "Ks values")
    
    return(p)
}


#' Find line intersect between pairs of Gaussian mixtures
#'
#' This function finds x-axis coordinate of n-1 intersections between lines 
#' of n Gaussian mixtures. Thus, it will find 1 intersection for Ks distros
#' with 2 peaks, 2 intersections for distros with 2 peaks, and so on.
#' 
#'
#' @param ks A numeric vector of Ks values.
#' @param peaks A list with mean, standard deviation, and amplitude of Ks
#'
#' @return A numeric scalar or vector with the x-axis coordinates of the 
#' intersections.
#' @importFrom ggplot2 ggplot_build
#' @export
#' @rdname find_intersect_mixtures
#' @examples
#' data(gma_dups_kaks)
#' ks <- gma_dups_kaks$Ks
#' ks <- ks[!is.na(ks)]
#' 
#' # Remove Ks values >2 for testing purposes
#' ks <- ks[ks <= 2]
#' 
#' # Create list of peaks
#' peaks <- find_ks_peaks(ks, npeaks = 3)
#'
#' # Get intersects
#' inter <- find_intersect_mixtures(ks, peaks)
find_intersect_mixtures <- function(ks, peaks) {
    
    p <- plot_ks_peaks(ks, peaks)
    npeaks <- length(peaks$mean)
    if(npeaks == 1) {
        stop("Cannot find intersect of peaks with only 1 peak.")
    }
    
    # Create list of density line indices to iterate through
    iteration_list <- list(
        c(2,3), c(3,4), c(4,5), c(5,6), c(6,7), c(7,8), c(8,9)
    )
    iteration_list <- iteration_list[seq_len(npeaks-1)]
    
    # Get intersection between density line i and density line i+1    
    ints <- unlist(lapply(iteration_list, function(x) {
        l1 <- x[1]
        l2 <- x[2]
        line_df <- data.frame(
            x = ggplot_build(p)$data[[l1]]$x,
            line1 = ggplot_build(p)$data[[l1]]$y,
            line2 = ggplot_build(p)$data[[l2]]$y
        )
        # Get minimal distance between lines along y axis
        line_df$delta = line_df$line1 - line_df$line2
        
        # Get x value for minimal delta y
        int <- line_df$x[which(diff(sign(diff((abs(line_df$delta))))) == 2)+1]
        return(int)
    }))
    return(ints)
}


#' Split gene pairs based on their Ks peaks
#' 
#' The purpose of this function is to classify gene pairs by age when there
#' are 2+ Ks peaks. This way, newer gene pairs are found within a 
#' certain number of standard deviations from the highest peak, 
#' and older genes are found close within smaller peaks.
#'
#' @param ks_df A 3-column data frame with gene pairs in columns 1 and 2,
#' and Ks values for the gene pair in column 3.
#' @param peaks A list with mean, standard deviation, and amplitude of Ks
#' peaks as generated by \code{find_ks_peaks}.
#' @param nsd Numeric with the number of standard deviations to consider
#' for each peak.
#'
#' @return A list with the following elements:
#' \describe{
#'   \item{pairs}{A 4-column data frame with the variables 
#'                \strong{dup1} (character), \strong{dup2} (character), 
#'                \strong{ks} (numeric), and \strong{peak} (numeric),
#'                representing duplicate gene pair, Ks values, and peak ID,
#'                respectively.}
#'   \item{plot}{A ggplot object with Ks peaks as returned by 
#'               \code{plot_ks_peaks}, but with dashed red lines indicating
#'               boundaries for each peak.}
#' }
#' 
#' @importFrom ggplot2 geom_vline
#' @export
#' @rdname split_genes_by_peak
#' @examples
#' data(gma_dups_kaks)
#'
#' # Create a data frame of duplicate pairs and Ks values
#' ks_df <- gma_dups_kaks[!is.na(gma_dups_kaks$Ks), c("dup1", "dup2", "Ks")]
#' 
#' # Remove Ks values >1 for testing purposes
#' ks_df <- ks_df[ks_df$Ks <= 1, ]
#'
#' # Create list of peaks
#' peaks <- find_ks_peaks(ks_df$Ks, npeaks = 2)
#' 
#' # Split pairs
#' spairs <- split_pairs_by_peak(ks_df, peaks) 
split_pairs_by_peak <- function(ks_df, peaks, nsd = 2) {
    
    names(ks_df) <- c("dup1", "dup2", "ks")
    npeaks <- length(peaks$mean)
    
    # Get minimum, intersection points, and maximum 
    inter <- find_intersect_mixtures(ks_df$ks, peaks)
    min_boun <- peaks$mean[1] - nsd * peaks$sd[1]
    max_boun <- peaks$mean[npeaks] + nsd * peaks$sd[npeaks]
    cutpoints <- c(min_boun, inter, max_boun)
    
    # Plot histogram with cutpoints in "brown2" dashed lines
    p <- plot_ks_peaks(ks_df$Ks, peaks)
    for(i in seq_along(cutpoints)) {
        p <- p + geom_vline(xintercept = cutpoints[i],
                            linetype = "dashed", color = "brown2")
    }
    
    # Create list of intervals
    int_list <- lapply(seq_len(length(cutpoints)-1), function(x) {
        return(c(cutpoints[x], cutpoints[x] + 1))
    })
    
    # Create list of data frames for each interval
    split_pairs <- Reduce(rbind, lapply(seq_along(int_list), function(x) {
        ivec <- int_list[[x]]
        pairs <- ks_df[ks_df$ks >= ivec[1] & ks_df$ks < ivec[2], ]
        pairs$peak <- x
        return(pairs)
    }))
    
    result_list <- list(pairs = split_pairs, plot = p)
    
}


