

#' Find optimal number of peaks in Ks distribution
#' 
#' @param ks A numeric vector of Ks values.
#' @param bootstraps Numeric scalar with the number of bootstrap realizations 
#' of the likelihood ratio statistic. We recommend using a minimum of 1000 
#' bootstraps. Default: 1000.
#' @param max_components Numeric scalar with the maximum number of components 
#' to test. Default: 2. 
#' @param signif Numeric scalar with the significance level for the 
#' likelihood ratio test. Default: 0.05.
#' @param epsilon Numeric scalar with the convergence criterion for the
#' expectation-maximization algorithm.
#'
#' @importFrom mixtools boot.comp
#' @export
#' @rdname find_peak_number
#' @return A numeric scalar with the optimal number of peaks.
#' @examples 
#' data(gma_dups_kaks)
#' ks <- gma_dups_kaks$Ks
#' ks <- ks[!is.na(ks)]
#' 
#' # Remove Ks values > 1 for testing purposes
#' ks <- ks[ks <= 1]
#'
#' # Using only 5 bootstraps for testing purposes
#' bootstraps <- 5
#' npeaks <- find_peak_number(ks, bootstraps, max_components = 2)
#'
find_peak_number <- function(ks, bootstraps = 1000, max_components = 2,
                             signif = 0.05, epsilon = 1e-3) {
    
    # Find the optimal number of peaks
    npeaks <- mixtools::boot.comp(
        ks, max.comp = max_components, B = bootstraps, 
        mix.type = "normalmix", sig = signif, epsilon = epsilon,
        verb = FALSE, hist = FALSE
    )
    
    pvals <- npeaks$p.values
    n_pvals <- length(pvals)
    
    number <- n_pvals
    if(pvals[n_pvals] < signif) {
        number <- n_pvals + 1
    } 
    return(n_pvals)
}



#' Find peaks in a Ks distribution by fitting Gaussian Mixture Models (GMMs)
#'
#' @param ks A numeric vector of Ks values.
#' @param npeaks Numeric scalar indicating the number of peaks in 
#' the distribution. If you don't know how many peaks there are, 
#' the optimal number of peaks can be estimated with \code{find_peak_number}. 
#' Default: 1.
#' @param epsilon Numeric scalar with the convergence criterion for the
#' expectation-maximization algorithm.
#'
#' 
#' @return A list with the following elements:
#' \describe{
#'   \item{mean}{Numeric with the estimated means.}
#'   \item{sd}{Numeric with the estimated standard deviations.}
#'   \item{lambda}{Numeric with the estimated mixture weights.}
# }
#' @importFrom mixtools normalmixEM
#' @export
#' @rdname find_ks_peaks
#' @examples 
#' data(gma_dups_kaks)
#' ks <- gma_dups_kaks$Ks
#' ks <- ks[!is.na(ks)]
#' 
#' # Remove Ks values >1 for testing purposes
#' ks <- ks[ks <= 1]
#' 
#' peaks <- find_ks_peaks(ks, npeaks = 2)
find_ks_peaks <- function(ks, npeaks = 1, epsilon = 1e-3) {
    
    # Find peaks
    peaks <- mixtools::normalmixEM(
        ks, 
        k = npeaks, 
        epsilon = epsilon
    )
    
    # Create result list
    peak_list <- list(
        mean = peaks$mu, 
        sd = peaks$sigma, 
        lambda = peaks$lambda
    )
    return(peak_list)
}


#' Plot histogram of Ks distribution with peaks
#'
#' @param ks A numeric vector of Ks values.
#' @param peaks A list with mean, standard deviation, and amplitude of Ks
#' peaks as generated by \code{find_ks_peaks}.
#'
#'
#'
#'
#' @importFrom ggplot2 ggplot aes_ geom_histogram ggplot stat_function
#' labs theme_bw
#' @importFrom stats dnorm
#' @rdname plot_ks_distro
#' @export
#' @examples 
#' data(gma_dups_kaks)
#' ks <- gma_dups_kaks$Ks
#' ks <- ks[!is.na(ks)]
#' 
#' # Remove Ks values >1 for testing purposes
#' ks <- ks[ks <= 1]
#'
#' # Create list of peaks
#' peaks <- find_ks_peaks(ks, npeaks = 2)
#'
#' # Plot
#' plot_ks_distro(ks, peaks)
plot_ks_distro <- function(ks, peaks = NULL) {
    
    ks_df <- data.frame(ks = ks)
    
    # Define color palette
    pal <- as.list(
        c("#80796BFF", "#6A6599FF", "#79AF97FF", "#B24745FF", "#00A1D5FF", 
          "#DF8F44FF", "#374E55FF")
    )
    
    # Plot 
    p <- ggplot(ks_df, aes_(x = ~ks)) +
        geom_histogram(binwidth = 0.05, color = "black", fill = "grey80") +
        mapply(function(mean, sd, lambda, n, binwidth, color) {
            stat_function(geom = "line", fun = function(x) {
                (dnorm(x, mean = mean, sd = sd)) * n * binwidth * lambda
            }, 
            color = color, size = 1.5)
        }, mean = peaks$mean, sd = peaks$sd, lambda = peaks$lambda,
        n = length(ks_df$ks), binwidth = 0.05,
        color = pal) +
        theme_bw() +
        labs(title = "Ks distribution with peaks", y = "Frequency",
             x = "Ks values")
    
    return(p)
}


